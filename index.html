<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<title>Keycaps</title>
	</head>
	<body>
		<style>
			body { padding: 0; margin: 0; overflow: hidden; }
			.controls { position: absolute; left: 10px; top: 10px; }
			.info { position: absolute; right: 10px; bottom: 10px; }
		</style>

		<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/87/three.min.js"></script>
		<script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
		<script src="https://sole.github.io/tween.js/build/tween.min.js"></script>
		<script src="keycaps.json"></script>

		<script>sets=[]</script>
		<script src="layouts/Keycap Profiles.json"></script>
		<script src="layouts/Default 60.json"></script>
		<script src="layouts/PMK Grab Bag (Aug 23, 2017).json"></script>
		<script src="layouts/GB-Retro-DSA.json"></script>
		<script src="layouts/ANSI 104.json"></script>
		<script src="layouts/Leopold FC660m.json"></script>
		<script src="layouts/Symbolics-364000.json"></script>

		<div class="controls">
			<input type="file" id="files" name="files[]" multiple="multiple" accept=".json"/>
			<select id="preset"></select>
		</div>

		<div class="info"><a href="https://github.com/joric/keycaps">github</a></div>

		<script>
			var container, stats;
			var camera, cameraTarget, scene, renderer;
			var obj_names = [];
			var antialias = !!location.hostname;
			var mouse = { x:0, y:0, pressed: false, moved: false, clicks: 0 }
			var selected;
			var selectTimer = null;
			var clickTimer = null;
			var loadedKeycaps = 0;
			var totalKeycaps = 0;

			function pickObject() {
				var vector = new THREE.Vector3(mouse.x, mouse.y, 1);
				vector.unproject(camera);
				var ray = new THREE.Raycaster(camera.position, vector.sub(camera.position).normalize());
				var intersects = ray.intersectObjects(scene.children);
				return intersects.length ? intersects[0].object : null;
			}

			function moveAndLookAt(camera, dstpos, dstlookat) {
				var origpos = new THREE.Vector3().copy(camera.position);
				var origrot = new THREE.Euler().copy(camera.rotation);

				camera.position.set(dstpos.x, dstpos.y, dstpos.z);
				camera.lookAt(dstlookat);
				var dstrot = new THREE.Euler().copy(camera.rotation);

				camera.position.set(origpos.x, origpos.y, origpos.z);
				camera.rotation.set(origrot.x, origrot.y, origrot.z);

				var dest = new THREE.Quaternion().setFromEuler(dstrot);
				var o = {t: 0};

				new TWEEN.Tween(o).to({t: 1}, 500).onUpdate(function () {
					camera.position.lerpVectors(origpos, dstpos, o.t);
					camera.quaternion.slerp(dest, o.t);
				}).easing(TWEEN.Easing.Cubic.InOut).start();
			}

			function computeSceneBounds(object) {
				var scope = new THREE.Box3();
				var v1 = new THREE.Vector3();
				object.updateMatrixWorld( true );
				object.traverse( function ( node ) {
					if (node instanceof THREE.Mesh && node.visible) {
						var i, l;
						var geometry = node.geometry;
						if ( geometry !== undefined ) {
							if ( geometry.isGeometry ) {
								var vertices = geometry.vertices;
								for ( i = 0, l = vertices.length; i < l; i ++ ) {
									v1.copy( vertices[ i ] );
									v1.applyMatrix4( node.matrixWorld );
									scope.expandByPoint( v1 );
								}
							} else if ( geometry.isBufferGeometry ) {
								var attribute = geometry.attributes.position;
								if ( attribute !== undefined ) {
									for ( i = 0, l = attribute.count; i < l; i ++ ) {
										v1.fromBufferAttribute( attribute, i ).applyMatrix4( node.matrixWorld );
										scope.expandByPoint( v1 );
									}
								}
							}
						}
					}
				});
				return scope;
			}

			function computeSceneBounds2(scene) {
				var bounds = new THREE.Box3();
				scene.traverse(function (child) {
					if (child instanceof THREE.Mesh && child.visible) {
						var childbox = child.geometry.boundingBox.clone();
						childbox.translate( child.localToWorld(new THREE.Vector3()));
						bounds.union( childbox );
					}
				});
				var size = bounds.getSize();
				radius = Math.max(size.x, Math.max(size.y, size.z));
				return {center: bounds.getCenter(), radius: radius};
			}

			document.addEventListener('mousedown', function(event) {
				mouse.xc = mouse.x;
				mouse.yc = mouse.y;
				mouse.pressed = true;
				mouse.moved = false;
				mouse.clicks++;
				clickTimer = setTimeout(function() { mouse.clicks = 0; }, 300);

				var obj = pickObject();

				if (selected && obj!=selected) {
					selected.material.color.setHex(selected.currentHex);
					selected = null;
				}

				selectTimer = setTimeout(function() {
					var obj = pickObject();
					if (obj && obj!=selected) {
						if (selected) selected.material.color.setHex(selected.currentHex);
						selected = obj;
						selected.currentHex = selected.material.color.getHex();
						selected.material.color.setHex(0xff0000);
					}	
				}, 500);

			}, false);

			function zoomIn(obj) {
				var center = obj.position;
				controls.target.copy(center);
				var newpos = new THREE.Vector3(center.x, center.y+75, center.z);
				moveAndLookAt(camera, newpos, center)
			}

			function zoomOut() {
				var bounds = computeSceneBounds(scene);
				var size = bounds.getSize();
				var center = bounds.getCenter();
				var radius = Math.max(size.x, Math.max(size.y, size.z));
				controls.target.copy(center);
				var newpos = new THREE.Vector3(center.x, center.y + radius*2.5, center.z);
				moveAndLookAt(camera, newpos, center)
			}

			document.addEventListener('mouseup', function(event) {
				clearTimeout(selectTimer);
				mouse.pressed = false;

				if (mouse.clicks) {
					var obj = pickObject();
					if (obj) {
						zoomIn(obj);
					} else {
						zoomOut();
					}
				}

			}, false);

			document.addEventListener('mousemove', function(event) {
				clearTimeout(selectTimer);
				mouse.moved = true;
				mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
				mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
			}, false);

			init();
			animate();

			function initScene() {
				scene = new THREE.ObjectLoader().parse(data);
				camera = scene.getObjectByName("Camera");
				onWindowResize();
				pointLight = new THREE.PointLight( 0xffffff );
				pointLight.position.set(1,1,2);
				camera.add(pointLight);
				obj_names = [];
				scene.traverse( function(obj) {
					if ( obj instanceof THREE.Mesh ) {
						obj.geometry.scale(-1,-1,1);
						obj.visible = false;
						obj.geometry.computeBoundingBox();
						obj_names.push(obj.name);
					}
				});
				camera.up.set( 0, 0, 1 );
				controls = new THREE.OrbitControls( camera, container );
				scene.background = new THREE.Color( 0xdddddd );

				camera.position.set(0,10000,0);
			}


			function init() {
				document.getElementById('files').addEventListener('change', function(evt){
					for (var i = 0, f; f = evt.target.files[i]; i++) {
						try {
							var file = evt.target.files[i];
							var start = 0;
							var stop = file.size - 1;
							var reader = new FileReader();
							reader.onloadend = function(evt) {
								if (evt.target.readyState == FileReader.DONE) {
									var json = evt.target.result;
									deserialize(JSON.parse(json));
								}
							};
							var blob = file.slice(start, stop + 1);
							reader.readAsBinaryString(blob);
						} catch (err) {
							console.log(err.message);
						}
					}
				});

				document.getElementById('preset').addEventListener('change', function(evt) {
					deserialize(sets[this.selectedIndex]);
				}, false);

				[].slice.call(document.getElementsByTagName('script')).forEach(function(obj) {
					if (obj.src.includes('layouts')) {
						var option = document.createElement('option');
						option.text = obj.getAttribute('src').replace(/^.*\/|\.\w+$/g,'');
						document.getElementById('preset').add(option);
					}
				});

				container = document.createElement( 'div' );
				document.body.appendChild( container );
				renderer = new THREE.WebGLRenderer( { antialias: antialias } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );
				window.addEventListener( 'resize', onWindowResize, false );

				deserialize(sets[0]);
			}

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			function render_html_to_canvas(html, ctx, x, y, w, h, cb, canvas, obj) {
				var doc = document.implementation.createHTMLDocument('');
				doc.body.innerHTML = html;
				doc.documentElement.setAttribute('xmlns', doc.documentElement.namespaceURI);
				var xml = (new XMLSerializer).serializeToString(doc.body);
				var svg = '<svg xmlns="http://www.w3.org/2000/svg" width="'+w+'" height="'+h+'">' +
					'<foreignObject width="100%" height="100%">'+xml+'</foreignObject></svg>';
				var url = 'data:image/svg+xml;charset=utf-8,'+encodeURIComponent(svg);
				var img = new Image();
				img.onload = function() { ctx.drawImage(img, x, y); cb(canvas, obj); }
				img.src = url;
			}

			function makeTexture(w, h, color, textColor, text, fontSize, obj, cb) {
				fontSize = fontSize*fontSize+60;

				var canvas = document.createElement( 'canvas' );
				canvas.width = w;
				canvas.height = h;
				var ctx = canvas.getContext( '2d' );

				ctx.fillStyle = color;
				ctx.fillRect(0, 0, w, h);

				var render_html = true;
				if (render_html) {
					var html = '<div style="display: table-cell; text-align: center; vertical-align: middle;'
					//+'border: 1px solid black;'
					+'color: '+textColor+'; background-color: '+ color
					+';font: '+fontSize+'px Arial'
					+';width: 256px; height: 240px;">'+
					'<span style="word-break: break-all;">'+text.replace('\n','<br/>')+'</span></div>';
					render_html_to_canvas(html, ctx, 0, 0, w, h, cb, canvas, obj);
					return;
				}

				var tx = canvas.width / 2;
				var ty = canvas.height / 2 + fontSize / 3;
				ctx.font = ''+fontSize+'px Arial';
				ctx.textAlign = 'center';
				ctx.fillStyle = textColor;
				ctx.fillText(text, tx, ty);
				cb(canvas, obj);
			}

			function profile_row(profile, row, rows) {
				if (profile=='SA') return 3;
				if (rows==6) return [1,1,2,3,4,4][row];
				else if (rows==5) return [1,2,3,4,4][row];
				return row>3 ? 4 : Math.floor(row+1);
			}

			function add_keycap(x, y, prop, caption, row, rows) {
				var profile = 'DCS';
				var space = prop.w>=6.25;
				rs = '';

				['DCS','DSA','SA','G20'].forEach(function(s) {if (prop.p.startsWith(s)) profile = s; });
				['R1','R2','R3','R4'].forEach( function(s) { if (prop.p.includes(' '+s)) rs = s; });

				if (profile=='DSA' && rs=='SPACE') profile='DCS';
				if (profile=='SA' && rs=='') rs='R3';
				if (profile=='DSA' && prop.w>1) profile='DCS';
				if (profile == 'DSA') rs='R3';

				//if (profile=='SA' && rs=='R3') rs='R3.001';
				//if (profile=='DSA' && rs=='R3') rs='R3.001';

				var r = profile_row(profile, row, rows);

				if (rs=='') rs = 'R' + r;

				if (profile=='SA' && rs=='R3') {
					if (prop.w==1.5) rs='R2';
					if (prop.w==1.25) rs='R4';
					if (prop.w==2) rs='R1';
				}

				if (profile=='DCS' && rs=='R4') {
					if (prop.w==2) rs='R1';
				}

				var id = rs + ( prop.w>1 ? ' '+prop.w : '');
				var name = space ? (profile+' SPACE' ) : (profile + ' ' + id);

				var obj = scene.getObjectByName(name);
				obj = obj ? obj.clone() : scene.getObjectByName(profile+' R1').clone();
				s = 19;
				obj.position.set(142 - (x+prop.w/2)*s, 0, 50-y*s);
				obj.visible = true;


				makeTexture(256, 256, prop.c, prop.t, caption, prop.f, obj, function(canvas, obj) {
					obj.material = new THREE.MeshPhongMaterial( { color: 0xffffff, specular: 0x101010, wireframe: false } )
					//obj.material = new THREE.MeshLambertMaterial( { color: 0xffffff } );
					obj.material.map = new THREE.Texture(canvas);
					obj.material.map.needsUpdate = true;
					scene.add(obj);
					loadedKeycaps++;
				});
			}

			function deserialize(data) {
				initScene();
				var x = 0;
				var y = 0;
				var prop = {c:0,t:0,p:'',a:0,f:0,x:0,y:0,sm:'',w:1,h:1,c:'#ffffff',t:'#000000'};
				var rows = 0;
				var row = 0;
				totalKeycaps = 0;
				loadedKeycaps = 0;
				data.forEach(function(o) {if (Array.isArray(o)) rows++; });
				data.forEach(function(o) {
					if (Array.isArray(o)) {
						o.forEach(function(e) {
							if (typeof e == 'string') {
								add_keycap(x,y,prop,e,row,rows);
								totalKeycaps++;
								x += prop.w;
								prop.w = prop.h = 1;
							} else {
								Object.keys(e).forEach(function(key) { prop[key] = e[key]; });
								x += prop.x;
								y += prop.y;
								prop.x = prop.y = 0;
							}
						});
						x = 0;
						y++;
						row++;
					}
				});
			}

			function animate() {
				requestAnimationFrame( animate );
				TWEEN.update();
				render();

				if (loadedKeycaps>0 && loadedKeycaps==totalKeycaps) {
					loadedKeycaps = 0;
					zoomOut();
				}
			}

			function render() {
				renderer.render( scene, camera );
			}

		</script>
	</body>
</html>
