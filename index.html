<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<title>Keycaps</title>
	</head>
	<body>
		<style>
			body { padding: 0; margin: 0; overflow: hidden; }
			.controls { position: absolute; left: 10px; top: 10px; }
			.info { position: absolute; right: 10px; bottom: 10px; }
		</style>

		<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/87/three.min.js"></script>
		<script src="http://threejs.org/examples/js/controls/OrbitControls.js"></script>
		<script src="keycaps.json"></script>

		<script>sets=[]</script>
		<script src="layouts/Keycap Profiles.json"></script>
		<script src="layouts/Default 60.json"></script>
		<script src="layouts/PMK Grab Bag (Aug 23, 2017).json"></script>
		<script src="layouts/GB-Retro-DSA.json"></script>
		<script src="layouts/ANSI 104.json"></script>
		<script src="layouts/Leopold FC660m.json"></script>
		<script src="layouts/Symbolics-364000.json"></script>

		<div class="controls">
			<input type="file" id="files" name="files[]" multiple="multiple" accept=".json"/>
			<select id="preset"></select>
		</div>

		<div class="info"><a href="https://github.com/joric/keycaps">github</a></div>

		<script>
			var container, stats;
			var camera, cameraTarget, scene, renderer;
			var obj_names = [];
			var antialias = !!location.hostname;
			var mouse = { x: 0, y: 0, pressed: false }, selected;

			document.addEventListener('mousedown', function(event) { 
				mouse.pressed = true;
				var vector = new THREE.Vector3(mouse.x, mouse.y, 1);
				vector.unproject(camera);
				var ray = new THREE.Raycaster(camera.position, vector.sub(camera.position).normalize());
				var intersects = ray.intersectObjects(scene.children);
				if (intersects.length > 0 && mouse.pressed) {
					if (intersects[0].object != selected) {
						if (selected) selected.material.color.setHex(selected.currentHex);
						selected = intersects[0].object;
						selected.currentHex = selected.material.color.getHex();
						selected.material.color.setHex(0xff0000);
					}
				} else {
					if (selected) selected.material.color.setHex(selected.currentHex);
					selected = null;
				}
			}, false);

			document.addEventListener('mouseup', function(event) {
				mouse.pressed = false;
			}, false);

			document.addEventListener('mousemove', function(event) {
				mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
				mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
			}, false);

			init();
			animate();

			function initScene() {
				scene = new THREE.ObjectLoader().parse(data);
				camera = scene.getObjectByName("Camera");
				onWindowResize();
				pointLight = new THREE.PointLight( 0xffffff );
				pointLight.position.set(1,1,2);
				camera.add(pointLight);
				obj_names = [];
				scene.traverse( function(obj) {
					if ( obj instanceof THREE.Mesh ) {
						obj.geometry.scale(-1,-1,1);
						obj.visible = false;
						obj_names.push(obj.name);
					}
				});
				camera.up.set( 0, 0, 1 );
				controls = new THREE.OrbitControls( camera, container );
				scene.background = new THREE.Color( 0xdddddd );
			}


			function init() {
				document.getElementById('files').addEventListener('change', function(evt){
					for (var i = 0, f; f = evt.target.files[i]; i++) {
						try {
							var file = evt.target.files[i];
							var start = 0;
							var stop = file.size - 1;
							var reader = new FileReader();
							reader.onloadend = function(evt) {
								if (evt.target.readyState == FileReader.DONE) {
									var json = evt.target.result;
									deserialize(JSON.parse(json));
								}
							};
							var blob = file.slice(start, stop + 1);
							reader.readAsBinaryString(blob);
						} catch (err) {
							console.log(err.message);
						}
					}
				});

				var ctrl = document.getElementById('preset');
				ctrl.addEventListener('change', function(evt) {
					var x = document.getElementById('preset');
					deserialize(sets[x.options[x.selectedIndex].value]);
				}, false);

				var scripts = document.body.getElementsByTagName('script');
				var j = 0;
				for (var i = 0; i < scripts.length; i++) {
					var s = /.*\/(.*)\.json$/.exec(scripts[i].getAttribute('src'));
					if (s) {
						var option = document.createElement('option');
						option.text = s[1];
						option.value = j;
						ctrl.add(option);
						j++;
					}
				}

				container = document.createElement( 'div' );
				document.body.appendChild( container );
				renderer = new THREE.WebGLRenderer( { antialias: antialias } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );
				window.addEventListener( 'resize', onWindowResize, false );

				deserialize(sets[0]);
			}

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			function animate() {
				requestAnimationFrame( animate );
				render();
			}

			function render() {
				renderer.render( scene, camera );
			}


			function render_html_to_canvas(html, ctx, x, y, w, h, cb, canvas, obj) {
				var doc = document.implementation.createHTMLDocument('');
				doc.body.innerHTML = html;
				doc.documentElement.setAttribute('xmlns', doc.documentElement.namespaceURI);
				var xml = (new XMLSerializer).serializeToString(doc.body);
				var svg = '<svg xmlns="http://www.w3.org/2000/svg" width="'+w+'" height="'+h+'">' +
					'<foreignObject width="100%" height="100%">'+xml+'</foreignObject></svg>';
				var url = 'data:image/svg+xml;charset=utf-8,'+encodeURIComponent(svg);
				var img = new Image();
				img.onload = function() { ctx.drawImage(img, x, y); cb(canvas, obj); }
				img.src = url;
			}

			function makeTexture(w, h, color, textColor, text, fontSize, obj, cb) {
				fontSize = fontSize*fontSize+60;

				var canvas = document.createElement( 'canvas' );
				canvas.width = w;
				canvas.height = h;
				var ctx = canvas.getContext( '2d' );

				ctx.fillStyle = color;
				ctx.fillRect(0, 0, w, h);

				var render_html = true;
				if (render_html) {
					var html = '<div style="display: table-cell; text-align: center; vertical-align: middle;'
					//+'border: 1px solid black;'
					+'color: '+textColor+'; background-color: '+ color
					+';font: '+fontSize+'px Arial'
					+';width: 256px; height: 240px;">'+
					'<span style="word-break: break-all;">'+text.replace('\n','<br/>')+'</span></div>';
					render_html_to_canvas(html, ctx, 0, 0, w, h, cb, canvas, obj);
					return;
				}

				var tx = canvas.width / 2;
				var ty = canvas.height / 2 + fontSize / 3;
				ctx.font = ''+fontSize+'px Arial';
				ctx.textAlign = 'center';
				ctx.fillStyle = textColor;
				ctx.fillText(text, tx, ty);
				cb(canvas, obj);
			}

			function profile_row(profile, row, rows) {
				if (profile=='SA') return 3;
				if (rows==6) return [1,1,2,3,4,4][row];
				else if (rows==5) return [1,2,3,4,4][row];
				return row>3 ? 4 : Math.floor(row+1);
			}

			function add_keycap(x, y, prop, caption, row, rows) {
				var profile = 'DCS';
				var space = prop.w>=6.25;
				rs = '';

				['DCS','DSA','SA','G20'].forEach(function(s) {if (prop.p.startsWith(s)) profile = s; });
				['R1','R2','R3','R4'].forEach( function(s) { if (prop.p.includes(' '+s)) rs = s; });

				if (profile=='DSA' && rs=='SPACE') profile='DCS';
				if (profile=='SA' && rs=='') rs='R3';
				if (profile=='DSA' && prop.w>1) profile='DCS';
				if (profile == 'DSA') rs='R3';

				//if (profile=='SA' && rs=='R3') rs='R3.001';
				//if (profile=='DSA' && rs=='R3') rs='R3.001';

				var r = profile_row(profile, row, rows);

				if (rs=='') rs = 'R' + r;

				if (profile=='SA' && rs=='R3') {
					if (prop.w==1.5) rs='R2';
					if (prop.w==1.25) rs='R4';
					if (prop.w==2) rs='R1';
				}

				if (profile=='DCS' && rs=='R4') {
					if (prop.w==2) rs='R1';
				}

				var id = rs + ( prop.w>1 ? ' '+prop.w : '');
				var name = space ? (profile+' SPACE' ) : (profile + ' ' + id);

				var obj = scene.getObjectByName(name);
				obj = obj ? obj.clone() : scene.getObjectByName(profile+' R1').clone();
				s = 19;
				obj.position.set(142 - (x+prop.w/2)*s, 0, 50-y*s);
				obj.visible = true;

				makeTexture(256, 256, prop.c, prop.t, caption, prop.f, obj, function(canvas, obj) {
					obj.material = new THREE.MeshPhongMaterial( { color: 0xffffff, specular: 0x101010, wireframe: false } )
					//obj.material = new THREE.MeshLambertMaterial(  { color: 0xffffff } );
					obj.material.map = new THREE.Texture(canvas);
					obj.material.map.needsUpdate = true;
					scene.add(obj);
				});
			}

			function deserialize(data) {
				initScene();
				var x = 0;
				var y = 0;
				var prop = {c:0,t:0,p:'',a:0,f:0,x:0,y:0,sm:'',w:1,h:1,c:'#ffffff',t:'#000000'};
				var rows = 0;
				var row = 0;
				data.forEach(function(o) {if (Array.isArray(o)) rows++; });
				data.forEach(function(o) {
					if (Array.isArray(o)) {
						o.forEach(function(e) {
							if (typeof e == 'string') {
								add_keycap(x,y,prop,e,row,rows);
								x += prop.w;
								prop.w = prop.h = 1;
							} else {
								Object.keys(e).forEach(function(key) { prop[key] = e[key]; });
								x += prop.x;
								y += prop.y;
								prop.x = prop.y = 0;
							}
						});
						x = 0;
						y++;
						row++;
					}
				});
			}
		</script>
	</body>
</html>
